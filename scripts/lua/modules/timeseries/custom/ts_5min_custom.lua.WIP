--
-- (C) 2019 - ntop.org
--


--[[from --> https://www.ntop.org/guides/ntopng/api/timeseries/intro.html

----------VARI APPUNTI-------------

A schema can be seen as a table of a database. It specifies the data format and types. A schema is identified by it’s name and contains the following informations:

        Step: the expected interval, in seconds, between raw data points.
        Tags: a tag is a label which can be used to filter data. Example of tags are the interface name, host name and nDPI protocol name.
        Metrics: a metric is a particual value which is being measured. Example of metrics are the host bytes sent traffic, interface number of flows and ASN round trip time.
                All metrics must be consistent with the specified type (see below).
        Type: the type for all the metrics of the schema. Currently “counter” or “gauge”.
        Options: some driver specific options.

SCHEMA NAME: The two parts are separated by a single ":" (for example “host:ndpi”)

-ntopng provides metrics of two types, namely gauges (measure) and counters (incremental).

-ntopng itself can now be used as a timeseries exporter

Traffic elements (such as local hosts and interfaces) are iterated periodically and by some Lua scripts and their statistics are dumped in the form of timeseries.
Traffic elements are handled in some standard ways:

       1) Most traffic elements are implemented in C, and their statistics are passed to lua via the ::lua method.
          For example, AutonomousSystem::lua dumps the autonomous system statistics to lua. Important if the element has a ::tsLua method check out the case 2 below.

       2) Some other traffic elements are implemented in C, but their statistics are hold on a TimeseriesPoint rather then the element itself.
          For example, the local hosts data is stored into the HostTimeseriesPoint class.
          In order to add new timeseries for a local host, the HostTimeseriesPoint is the class to modify (and related ::lua method).

       3) Some traffic elements are implemented in Lua. Their state is stored in Redis usually in json form. This includes, for example, the SNMP devices.

Once the new metrics are available in lua it’s necessary to export such metrics as timeseries the metric should be declared in a timeseries schema and 
should be written to the timeseries driver; both actions can be implemented inside the custom timeseries scripts.

ntopng handles custom timeseries with updates every 1 minute for interfaces, 5 minutes for local hosts.
----------------
File ts_5min_custom.lua must contain a callback ts_custom.host_update_stats which is called by ntopng every 5 minutes for every active local host.
This callback accepts the following arguments:

       - "when" The time (expressed as a Unix Epoch) of the call
       - "hostname" The IP address of the host, possibly followed by a VLAN tag
       - "host" The host metrics in a lua table
       - "ifstats" The interface stats of the host interface
       - "verbose" and extra flag passed when ntopng is working in verbose mode

-----------------
File ts_minute_custom.lua must contain a callback ts_custom.iface_update_stats which is called by ntopng every minute for every monitored interface.
This callback accepts the following arguments:

        - "when"    The time (expressed as a Unix Epoch) of the call
        - "_ifname" The name of the monitored interface
        - "ifstats" The interface stats of the monitored interface
        - "verbose" and extra flag passed when ntopng is working in verbose mode

Callbacks can be used to append points to the timeseries. Indeed, once the schema is defined, it is necessary to append points to the timeseries.
The function used to append points to the timeseries is the ts_utils.append() 

(example: https://www.ntop.org/guides/ntopng/api/timeseries/adding_new_timeseries.html#example)

The first argument of ts_utils.append is the timeseries name and must be equal to the one specified when defining the schema.
The second argument is a table which must contain the tag (ifid) and the metric (packets) which must be set to their actual values.
As it can be seen from the example above, the field id of table ifstats is used to set tag ifid,
whereas the sum of ifstats.tcpPacketStats table fields retransmissions, out_of_order and lost are used as value for the metric packets.


]]

--TODO: fare in modo che non vengano create le time series se non è attiva la matrice arp

local ts_custom = {}
local ts_utils = require "ts_utils_core"

--(utility) inline if
local function in_if(cond, t, f)
	if cond then return t else return f end
end 

--###################################################################

local function setup()  --NOTE: schema aggiunto al file ts_5min.lua
    local schema
	--vedi graph_utils.lua linea 803 per l'unità di misura
end

--###################################################################

--NOTE: l'hostname degli host locali pare essere un MAC nel formato [xx:xx:xx:xx:xx:xx_v4], oun ipv4 o un un ipv6
function ts_custom.host_update_stats(when, hostname, host, ifstats, verbose)
    io.write("----------------------------------------------------\n HOST: "..hostname .. "\n")

    -- io.write("----------------------------------------------------\n FIND HOST TABLE WITH PARAM: "..hostname)
    -- tprint( interface.findHost(hostname) )
    -- io.write("\n")

    hostname = string.gsub( hostname, "_v4", "" )

    if ( not string.find(hostname, "::") ) and( (string.match(hostname, "^%x%x:%x%x:%x%x:%x%x:%x%x:%x%x$") ~= nil)  or
      (string.match(hostname, "^%x%x:%x%x:%x%x:%x%x:%x%x:%x%x%@%d+$") ~= nil) or
      string.find(hostname,".")) then --è un MAC o host locale. sto escludendo ipv6 insomma

        
        local info, as_s, as_c, mac

        if not string.find(hostname,".") then 
            info = interface.getMacInfo( hostname )
            mac = hostname
        else
            
            mac = interface.getHostInfo(hostname)["mac"]
            info = interface.getMacInfo( mac )
        end

        if info then
            as_s = info["talkers.asServer"]
            as_c = info["talkers.asClient"]

            --local host_addr = interface.findHost(hostname)
            --tprint( host_addr )        
            --if ( utils.isIPv6(hostname) ) then return end

            ts_utils.append("mac:local_talkers",
                {
                    ifid = ifstats.id, mac = mac,

                    num_as_server = as_s,
                    num_as_client = as_c
                },
                when, verbose
            )
            io.write("host "..hostname.." (mac:"..mac..") aggiunto: asClient: "..info["talkers.asClient"].." - asServer: "..info["talkers.asServer"].."\n")
        else
            io.write("host "..hostname.." NON AGGIUNTO, forse info non valido \n")
        end
            
    else
        io.write("host "..hostname.." ignorato\n")
    end
    io.write("\n----------------------------------------------------------------\n")
end

--setup()
return ts_custom



--[[
    host table
icmp.bytes.sent number 0
icmp.packets.sent number 0
udp.bytes.rcvd number 0
other_ip.packets.rcvd number 0
anomalous_flows.as_server number 0
udp.packets.rcvd number 0
tcp.packets.lost number 0
host_unreachable_flows.as_server number 0
icmp.packets.rcvd number 0
ndpi_categories table
ndpi_categories.Network string 20743|0
tcp.packets.rcvd number 0
total_flows.as_server number 0
contacts.as_server number 0
unreachable_flows.as_client number 0
host_unreachable_flows.as_client number 0
sites.old string {}
other_ip.bytes.sent number 0
instant number 1557735900
other_ip.packets.sent number 0
tcp.packets.retransmissions number 0
other_ip.bytes.rcvd number 0
tcp.bytes.rcvd number 0
active_flows.as_client number 1
active_flows.as_server number 0
udp.packets.sent number 5
total_flows.as_client number 23
icmp.bytes.rcvd number 0
tcp.packets.sent number 0
sites string { }
dns table
dns.rcvd table
dns.rcvd.num_replies_error number 0
dns.rcvd.num_replies_ok number 0
dns.rcvd.num_queries number 0
dns.sent table
dns.sent.num_replies_error number 0
dns.sent.num_replies_ok number 0
dns.sent.num_queries number 0
tcp.packets.out_of_order number 0
unreachable_flows.as_server number 0
anomalous_flows.as_client number 0
udp.bytes.sent number 1412
bytes.rcvd number 0
total_alerts number 0
ndpi table
ndpi.MDNS string 20743|0
bytes.sent number 20743
tcp.bytes.sent number 0
contacts.as_client number 1


MAC INFO
 table
devtype number 1
arp_requests.sent number 0
bytes.rcvd.anomaly_index number 0
throughput_trend_bps_diff number -277.0986328125
last_throughput_pps number 0.19992686808109
bytes.sent number 1386
source_mac boolean true
arp_replies.rcvd number 0
bytes.sent.anomaly_index number 0
pool number 0
duration number 7979
throughput_bps number 0.0
arp_replies.sent number 0
bridge_seen_iface_id number 1
num_hosts number 1
special_mac boolean false
throughput_trend_pps number 2
operatingSystem number 0
bytes.ndpi.unknown number 0
packets.sent number 1
seen.last number 1557740986
bytes.rcvd number 0
packets.rcvd number 0
location string lan
manufacturer string Hewlett Packard
mac string 00:01:E6:A1:49:FC
fingerprint string 
last_throughput_bps number 277.0986328125
throughput_trend_bps number 2
seen.first number 1557733008
arp_requests.rcvd number 0
packets.sent.anomaly_index number 0
throughput_pps number 0.0
packets.rcvd.anomaly_index number 0


]]
